{"version":3,"file":"collectionFetcher-CyPMU7pv.chunk.mjs","sources":["../src/services/collectionFetcher.js"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport moment from '@nextcloud/moment'\nimport { translate as t } from '@nextcloud/l10n'\n\nimport logger from './logger.js'\nimport { genFileInfo } from '../utils/fileUtils.js'\nimport { davClient } from './DavClient.ts'\n\n/**\n * @typedef {object} Collection\n * @property {string} basename - The name of the collection (ex: \"Athens\").\n * @property {string} filename - The filename of the collection (ex: \"/photos/admin/places/Athens\").\n * @property {string} source - The full source of the collection (ex: \"https://nextcloud_server1.test/remote.php/dav//photos/admin/places/Athens\").\n * @property {number} nbItems - The number of item in the collection.\n * @property {number} lastPhoto - The file id for the cover of the collection.\n */\n\n/**\n * @typedef {object} CollectionFile\n * @property {string} fileid - The id of the file.\n * @property {string} basename - The name of the file (ex: \"790-IMG_20180906_085724.jpg\").\n * @property {string} filename - The file name of the file (ex: \"/photos/admin/places/Athens/790-IMG_20180906_085724.jpg\").\n * @property {string} source - The full source of the collection (ex: \"https://nextcloud_server1.test/remote.php/dav//photos/admin/places/Athens/790-IMG_20180906_085724.jpg\").\n * @property {object} metadataPhotosSize - The metadata of the file.\n * @property {number} metadataPhotosSize.width - The width of the file.\n * @property {number} metadataPhotosSize.height - The height of the file.\n */\n\n/** @typedef {Object<string, Collection>} IndexedCollections */\n/** @typedef {Object<string, CollectionFile>} IndexedCollectionFiles */\n\n/**\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @return {string}\n */\nfunction getCollectionDavRequest(extraProps = []) {\n\treturn `<?xml version=\"1.0\"?>\n\t\t\t<d:propfind xmlns:d=\"DAV:\"\n\t\t\t\txmlns:oc=\"http://owncloud.org/ns\"\n\t\t\t\txmlns:nc=\"http://nextcloud.org/ns\"\n\t\t\t\txmlns:ocs=\"http://open-collaboration-services.org/ns\">\n\t\t\t\t<d:prop>\n\t\t\t\t\t<nc:last-photo />\n\t\t\t\t\t<nc:nbItems />\n\t\t\t\t\t${extraProps.join('')}\n\t\t\t\t</d:prop>\n\t\t\t</d:propfind>`\n}\n\n/**\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @return {string}\n */\nfunction getCollectionFilesDavRequest(extraProps = []) {\n\treturn `<?xml version=\"1.0\"?>\n\t\t\t<d:propfind xmlns:d=\"DAV:\"\n\t\t\t\txmlns:oc=\"http://owncloud.org/ns\"\n\t\t\t\txmlns:nc=\"http://nextcloud.org/ns\"\n\t\t\t\txmlns:ocs=\"http://open-collaboration-services.org/ns\">\n\t\t\t\t<d:prop>\n\t\t\t\t\t<d:getcontentlength />\n\t\t\t\t\t<d:getcontenttype />\n\t\t\t\t\t<d:getetag />\n\t\t\t\t\t<d:getlastmodified />\n\t\t\t\t\t<d:resourcetype />\n\t\t\t\t\t<nc:metadata-photos-size />\n\t\t\t\t\t<nc:metadata-photos-original_date_time />\n\t\t\t\t\t<nc:metadata-files-live-photo />\n\t\t\t\t\t<nc:has-preview />\n\t\t\t\t\t<nc:hidden />\n\t\t\t\t\t<oc:favorite />\n\t\t\t\t\t<oc:fileid />\n\t\t\t\t\t<oc:permissions />\n\t\t\t\t\t${extraProps.join('')}\n\t\t\t\t</d:prop>\n\t\t\t</d:propfind>`\n}\n\n/**\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<Collection|null>}\n */\nexport async function fetchCollection(path, options, extraProps = [], client = davClient) {\n\ttry {\n\t\tconst response = await client.stat(path, {\n\t\t\tdata: getCollectionDavRequest(extraProps),\n\t\t\tdetails: true,\n\t\t\t...options,\n\t\t})\n\n\t\tlogger.debug('[Collections] Fetched a collection: ', { data: response.data })\n\n\t\treturn formatCollection(response.data)\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.code === error.ABORT_ERR) {\n\t\t\treturn null\n\t\t}\n\n\t\tthrow error\n\t}\n}\n\n/**\n *\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<Collection[]>}\n */\nexport async function fetchCollections(path, options, extraProps = [], client = davClient) {\n\ttry {\n\t\tconst response = await client.getDirectoryContents(path, {\n\t\t\tdata: getCollectionDavRequest(extraProps),\n\t\t\tdetails: true,\n\t\t\t...options,\n\t\t})\n\n\t\tlogger.debug(`[Collections] Fetched ${response.data.length} collections: `, { data: response.data })\n\n\t\treturn response.data\n\t\t\t.filter(collection => collection.filename !== path)\n\t\t\t.map(formatCollection)\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.code === error.ABORT_ERR) {\n\t\t\treturn []\n\t\t}\n\n\t\tthrow error\n\t}\n}\n\n/**\n *\n * @param {object} rawCollection - An collection received from a webdav request.\n * @return {Collection}\n */\nfunction formatCollection(rawCollection) {\n\t// Ensure that we have a proper collaborators array.\n\tif (rawCollection.props.collaborators === undefined || rawCollection.props.collaborators === '') {\n\t\trawCollection.props.collaborators = []\n\t} else if (typeof rawCollection.props.collaborators.collaborator === 'object') {\n\t\tif (Array.isArray(rawCollection.props.collaborators.collaborator)) {\n\t\t\trawCollection.props.collaborators = rawCollection.props.collaborators.collaborator\n\t\t} else {\n\t\t\trawCollection.props.collaborators = [rawCollection.props.collaborators.collaborator]\n\t\t}\n\t}\n\n\t// Extract custom props.\n\trawCollection = genFileInfo(rawCollection)\n\n\t// Compute date range label.\n\tconst dateRange = JSON.parse(rawCollection.dateRange?.replace(/&quot;/g, '\"') ?? '{}')\n\tif (dateRange.start === null) {\n\t\tdateRange.start = moment().unix()\n\t\tdateRange.end = moment().unix()\n\t}\n\tconst dateRangeFormatted = {\n\t\tstartDate: moment.unix(dateRange.start).format('MMMM YYYY'),\n\t\tendDate: moment.unix(dateRange.end).format('MMMM YYYY'),\n\t}\n\tif (dateRangeFormatted.startDate === dateRangeFormatted.endDate) {\n\t\trawCollection.date = dateRangeFormatted.startDate\n\t} else {\n\t\trawCollection.date = t('photos', '{startDate} to {endDate}', dateRangeFormatted)\n\t}\n\n\treturn rawCollection\n}\n\n/**\n *\n * @param {string} path - Collections' root path.\n * @param {import('webdav').StatOptions} options - Options to forward to the webdav client.\n * @param {string[]} extraProps - Extra properties to add to the DAV request.\n * @param {import('webdav').WebDAVClient} client - The DAV client to use.\n * @return {Promise<CollectionFile[]>}\n */\nexport async function fetchCollectionFiles(path, options, extraProps = [], client = davClient) {\n\ttry {\n\t\tconst response = await client.getDirectoryContents(path, {\n\t\t\tdata: getCollectionFilesDavRequest(extraProps),\n\t\t\tdetails: true,\n\t\t\t...options,\n\t\t})\n\n\t\tconst fetchedFiles = response.data\n\t\t\t.map(file => genFileInfo(file))\n\t\t\t.filter(file => file.fileid)\n\n\t\tlogger.debug(`[Collections] Fetched ${fetchedFiles.length} new files: `, fetchedFiles)\n\n\t\treturn fetchedFiles\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.code === error.ABORT_ERR) {\n\t\t\treturn []\n\t\t}\n\n\t\tlogger.error('Error fetching collection files', { error })\n\t\tthrow error\n\t}\n}\n"],"names":["getCollectionDavRequest","extraProps","getCollectionFilesDavRequest","fetchCollection","path","options","client","davClient","response","logger","formatCollection","error","fetchCollections","collection","rawCollection","genFileInfo","dateRange","moment","dateRangeFormatted","t","fetchCollectionFiles","fetchedFiles","file"],"mappings":"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"}