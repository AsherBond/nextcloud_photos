{"version":3,"file":"FetchCollectionContentMixin-BQBuyj10.chunk.mjs","sources":["../src/mixins/FetchCollectionContentMixin.js"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { mapActions } from 'vuex'\n\nimport { showError } from '@nextcloud/dialogs'\n\nimport AbortControllerMixin from './AbortControllerMixin.js'\nimport { fetchCollection, fetchCollectionFiles } from '../services/collectionFetcher.js'\nimport logger from '../services/logger.js'\nimport SemaphoreWithPriority from '../utils/semaphoreWithPriority.js'\n\nexport default {\n\tname: 'FetchCollectionContentMixin',\n\n\tdata() {\n\t\treturn {\n\t\t\tfetchSemaphore: new SemaphoreWithPriority(1),\n\t\t\tloadingCollection: false,\n\t\t\tloadingCollectionFiles: false,\n\t\t\terrorFetchingCollection: null,\n\t\t\terrorFetchingCollectionFiles: null,\n\t\t}\n\t},\n\n\tmixins: [\n\t\tAbortControllerMixin,\n\t],\n\n\tmethods: {\n\t\t...mapActions([\n\t\t\t'appendFiles',\n\t\t\t'addCollections',\n\t\t\t'setCollectionFiles',\n\t\t]),\n\t\t/**\n\t\t * @param {string} collectionFileName\n\t\t * @param {string[]} [extraProps] - Extra properties to add to the DAV request.\n\t\t * @param {import('webdav').WebDAVClient} [client] - The DAV client to use.\n\t\t * @return {Promise<import('../services/collectionFetcher.js').Collection|null>}\n\t\t */\n\t\tasync fetchCollection(collectionFileName, extraProps, client) {\n\t\t\tif (this.loadingCollection) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis.loadingCollection = true\n\t\t\t\tthis.errorFetchingCollection = null\n\n\t\t\t\tconst collection = await fetchCollection(collectionFileName, { signal: this.abortController.signal }, extraProps, client)\n\t\t\t\tthis.addCollections({ collections: [collection] })\n\t\t\t\treturn collection\n\t\t\t} catch (error) {\n\t\t\t\tif (error.response?.status === 404) {\n\t\t\t\t\tthis.errorFetchingCollection = 404\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tthis.errorFetchingCollection = error\n\t\t\t\tlogger.error('[PublicCollectionContent] Error fetching collection', { error })\n\t\t\t\tshowError(this.t('photos', 'Failed to fetch collection.'))\n\t\t\t} finally {\n\t\t\t\tthis.loadingCollection = false\n\t\t\t}\n\n\t\t\treturn null\n\t\t},\n\n\t\t/**\n\t\t * @param {string} collectionFileName\n\t\t * @param {string[]} [extraProps] - Extra properties to add to the DAV request.\n\t\t * @param {import('webdav').WebDAVClient} [client] - The DAV client to use.\n\t\t * @param {((value: import('../services/collectionFetcher.js').CollectionFile, index: number, array: import('../services/collectionFetcher.js').CollectionFile[]) => any)[]} [mappers] - Callback that can transform files before they are appended.\n\t\t * @return {Promise<import('../services/collectionFetcher.js').CollectionFile[]>}\n\t\t */\n\t\tasync fetchCollectionFiles(collectionFileName, extraProps, client, mappers = []) {\n\t\t\tif (this.loadingCollectionFiles) {\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\tconst fetchSemaphoreSymbol = await this.fetchSemaphore.acquire()\n\n\t\t\ttry {\n\t\t\t\tthis.errorFetchingCollectionFiles = null\n\t\t\t\tthis.loadingCollectionFiles = true\n\n\t\t\t\tlet fetchedFiles = await fetchCollectionFiles(collectionFileName, { signal: this.abortController.signal }, extraProps, client)\n\t\t\t\tconst fileIds = fetchedFiles.map(file => file.fileid.toString())\n\n\t\t\t\tmappers.forEach(mapper => (fetchedFiles = fetchedFiles.map(mapper)))\n\n\t\t\t\tthis.appendFiles(fetchedFiles)\n\n\t\t\t\tif (fetchedFiles.length > 0) {\n\t\t\t\t\tawait this.$store.commit('setCollectionFiles', { collectionFileName, fileIds })\n\t\t\t\t}\n\n\t\t\t\treturn fetchedFiles\n\t\t\t} catch (error) {\n\t\t\t\tif (error.response?.status === 404) {\n\t\t\t\t\tthis.errorFetchingCollectionFiles = 404\n\t\t\t\t\treturn []\n\t\t\t\t}\n\n\t\t\t\tthis.errorFetchingCollectionFiles = error\n\n\t\t\t\tshowError(this.t('photos', 'Failed to fetch collections list.'))\n\t\t\t\tlogger.error('[PublicCollectionContent] Error fetching collection files', { error })\n\t\t\t} finally {\n\t\t\t\tthis.loadingCollectionFiles = false\n\t\t\t\tthis.fetchSemaphore.release(fetchSemaphoreSymbol)\n\t\t\t}\n\n\t\t\treturn []\n\t\t},\n\t},\n}\n"],"names":["FetchCollectionContentMixin","SemaphoreWithPriority","AbortControllerMixin","mapActions","collectionFileName","extraProps","client","collection","fetchCollection","error","logger","showError","mappers","fetchSemaphoreSymbol","fetchedFiles","fetchCollectionFiles","fileIds","file","mapper"],"mappings":"iPAcA,MAAeA,EAAA,CACd,KAAM,8BAEN,MAAO,CACN,MAAO,CACN,eAAgB,IAAIC,EAAsB,CAAC,EAC3C,kBAAmB,GACnB,uBAAwB,GACxB,wBAAyB,KACzB,6BAA8B,IACjC,CACE,EAED,OAAQ,CACPC,CACA,EAED,QAAS,CACR,GAAGC,EAAW,CACb,cACA,iBACA,oBACH,CAAG,EAOD,MAAM,gBAAgBC,EAAoBC,EAAYC,EAAQ,CAC7D,GAAI,KAAK,kBACR,OAAO,KAGR,GAAI,CACH,KAAK,kBAAoB,GACzB,KAAK,wBAA0B,KAE/B,MAAMC,EAAa,MAAMC,EAAgBJ,EAAoB,CAAE,OAAQ,KAAK,gBAAgB,QAAUC,EAAYC,CAAM,EACxH,OAAA,KAAK,eAAe,CAAE,YAAa,CAACC,CAAU,CAAG,CAAA,EAC1CA,CACP,OAAQE,EAAO,CACf,GAAIA,EAAM,UAAU,SAAW,IAC9B,OAAA,KAAK,wBAA0B,IACxB,KAGR,KAAK,wBAA0BA,EAC/BC,EAAO,MAAM,sDAAuD,CAAE,MAAAD,CAAO,CAAA,EAC7EE,EAAU,KAAK,EAAE,SAAU,6BAA6B,CAAC,CAC7D,QAAa,CACT,KAAK,kBAAoB,EAC7B,CAEG,OAAO,IACP,EASD,MAAM,qBAAqBP,EAAoBC,EAAYC,EAAQM,EAAU,CAAA,EAAI,CAChF,GAAI,KAAK,uBACR,MAAO,CAAA,EAGR,MAAMC,EAAuB,MAAM,KAAK,eAAe,QAAO,EAE9D,GAAI,CACH,KAAK,6BAA+B,KACpC,KAAK,uBAAyB,GAE9B,IAAIC,EAAe,MAAMC,EAAqBX,EAAoB,CAAE,OAAQ,KAAK,gBAAgB,QAAUC,EAAYC,CAAM,EAC7H,MAAMU,EAAUF,EAAa,IAAIG,GAAQA,EAAK,OAAO,SAAU,CAAA,EAE/D,OAAAL,EAAQ,QAAQM,GAAWJ,EAAeA,EAAa,IAAII,CAAM,CAAE,EAEnE,KAAK,YAAYJ,CAAY,EAEzBA,EAAa,OAAS,GACzB,MAAM,KAAK,OAAO,OAAO,qBAAsB,CAAE,mBAAAV,EAAoB,QAAAY,CAAS,CAAA,EAGxEF,CACP,OAAQL,EAAO,CACf,GAAIA,EAAM,UAAU,SAAW,IAC9B,OAAK,KAAA,6BAA+B,IAC7B,CAAA,EAGR,KAAK,6BAA+BA,EAEpCE,EAAU,KAAK,EAAE,SAAU,mCAAmC,CAAC,EAC/DD,EAAO,MAAM,4DAA6D,CAAE,MAAAD,CAAO,CAAA,CACvF,QAAa,CACT,KAAK,uBAAyB,GAC9B,KAAK,eAAe,QAAQI,CAAoB,CACpD,CAEG,MAAO,CAAA,CACP,CACD,CACF"}